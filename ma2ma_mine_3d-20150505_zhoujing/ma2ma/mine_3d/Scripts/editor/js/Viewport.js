var Viewport = function ( editor ) {	var signals = editor.signals;	var container = new UI.Panel();	container.setPosition( 'absolute' );	var info = new UI.Text();	info.setPosition( 'absolute' );	info.setRight( '5px' );	info.setBottom( '5px' );	info.setFontSize( '12px' );	info.setColor( '#ffffff' );	info.setValue( 'x: 0, y: 0, z: 0' );	container.add( info );    var measure = new UI.Text();    measure.setPosition( 'absolute' );    measure.setRight( '5px' );    measure.setBottom( '25px' );    measure.setFontSize( '12px' );    measure.setColor( '#ffffff' );    measure.setValue( '方位角: 0,倾角: 0, 空间距离: 0, 投影距离：0' );    container.add( measure );    measure.setDisplay('none');	var scene = editor.scene;    scene.obj_type = 'scene';	var sceneHelpers = editor.sceneHelpers;	var objects = [];    var operMode= 'select';    var draw_line;    var draw_line_init_point;    ///////////////////////////////////辅助面    var start_helperPlane = new THREE.Vector3();    var end_helperPlane = new THREE.Vector3();    var time = 0;    var meshCount = 0;    ///////////////////////////////////    /////////////////////////////////孤立点    var draw_particle;    var draw_particle_init_point;    ///////////////////////////////////////    /////////////////////////////////////////转换相机    var camera_type = 1;        //1是投影相机,2是正交相机    /////////////////////////////////////////////////    //var draw_line_count = 0;	// helpers	var grid = new THREE.GridHelper( 1000, 20 );	sceneHelpers.add( grid );	//    //var camera = new THREE.OrthographicCamera(-2000, 2000, 2000, -2000, 1, 50000)	var camera = new THREE.PerspectiveCamera( 50, 1, 1, 50000 );   //设置视角	camera.position.fromArray( editor.config.getKey( 'camera' ).position );	camera.lookAt( new THREE.Vector3().fromArray( editor.config.getKey( 'camera' ).target ) );  //设置视野中心坐标	//显示选择框	var selectionBox = new THREE.BoxHelper();	selectionBox.material.depthTest = false;	selectionBox.material.transparent = true;	selectionBox.visible = false;	sceneHelpers.add( selectionBox );    //显示移动操作组件	var transformControls = new THREE.TransformControls( camera, container.dom );	transformControls.addEventListener( 'change', function  () {		controls.enabled = true;		if ( transformControls.axis !== null ) {			controls.enabled = false;		}		if ( editor.selected !== null ) {			signals.objectChanged.dispatch( editor.selected );		}	} );	sceneHelpers.add( transformControls );    /////////////////////////////////////////20150504    //////////////////    var controls = new THREE.EditorControls( camera, container.dom );    controls.center.fromArray( editor.config.getKey( 'camera' ).target );    controls.addEventListener( 'change', function () {        transformControls.update();        signals.cameraChanged.dispatch( camera );    } );    //////////////////    /*var position = camera.position;    var target = controls.center;    var geometry = new THREE.PlaneGeometry(10000, 10000, 10, 10);    var material = new THREE.MeshBasicMaterial({ color: 0x00ff00,  opacity: 0.1, transparent: true,side: THREE.DoubleSide  });    var mesh = new THREE.Mesh( geometry, material );    mesh.position = target;    var normal_vector = new THREE.Vector3(position.x - target.x, position.y - target.y, position.z - target.z);    var normal_vector_length = Math.sqrt((normal_vector.x) * (normal_vector.x) + (normal_vector.y) * (normal_vector.y) + (normal_vector.z) * (normal_vector.z));    var theta_x = Math.PI / 2 - Math.acos(normal_vector.x / normal_vector_length);    var theta_y = Math.PI / 2 - Math.acos(normal_vector.y / normal_vector_length);    var theta_z = Math.PI / 2 - Math.acos(normal_vector.z / normal_vector_length);    //var theta = Math.atan((camera.position.z - target.z) / (camera.position.x - target.x));    mesh.rotation.x = theta_x;    mesh.rotation.y = theta_y;    mesh.rotation.z = theta_z;    mesh.obj_type = 'focus_plane';    //mesh.rotation.z = Math.PI / 2;    editor.addObject( mesh );    console.log(normal_vector);    console.log(theta_x , theta_y, theta_z);    console.log(mesh);*/    /////////////////////////////////////////20150504    //显示鼠标经过矿井的标示    var PI2 = Math.PI * 2;    var program = function ( context ) {        context.beginPath();        context.arc( 0, 0, 0.1, 0, PI2, true );        context.fill();    };    var sphereInter = new THREE.Sprite(        new THREE.SpriteCanvasMaterial( {                color: 0xff0000,                program: program }        )    );    sphereInter.scale.x = sphereInter.scale.y = 10;    sphereInter.visible = false;    sphereInter.scale.set(4,4,1.0);    sceneHelpers.add( sphereInter );    //显示画线时未点击时的线段    var tmpLine = new THREE.Line( new THREE.Geometry(), new THREE.LineBasicMaterial( { color: 0xff0000,linewidth: 1 } ), THREE.LineStrip );    tmpLine.visible = false;    sceneHelpers.add( tmpLine );    //地面    var horizontal_g = new THREE.PlaneGeometry( editor.world * 2 , editor.world * 2, 10,10 );    var horizontal_m = new THREE.MeshBasicMaterial({ color: 0xffffff,  opacity: 0.5, transparent: true,side: THREE.DoubleSide  });    var horizontal_plane = new THREE.Mesh( horizontal_g, horizontal_m );    horizontal_plane.rotation.x=Math.PI / 2;//    horizontal_plane.position.y=1;    horizontal_plane.visible = false;    sceneHelpers.add( horizontal_plane );	// fog	var oldFogType = "None";	var oldFogColor = 0xaaaaaa;	var oldFogNear = 1;	var oldFogFar = 5000;	var oldFogDensity = 0.00025;	// object picking	var ray = new THREE.Raycaster();	var projector = new THREE.Projector();	// events	var getIntersects = function ( event, object ) {		var rect = container.dom.getBoundingClientRect();		x = ( event.clientX - rect.left ) / rect.width;		y = ( event.clientY - rect.top ) / rect.height;		var vector = new THREE.Vector3( ( x ) * 2 - 1, - ( y ) * 2 + 1, 0.5 );		projector.unprojectVector( vector, camera );		ray.set( camera.position, vector.sub( camera.position ).normalize() );		if ( object instanceof Array ) {            //console.log(ray.intersectObjects( object ));			return ray.intersectObjects( object.filter(function(element){ return( element.visible === true)  }) );		}		return ray.intersectObject( object );	};	var onMouseDownPosition = new THREE.Vector2();	var onMouseUpPosition = new THREE.Vector2();    var onMouseMovePosition = new THREE.Vector2();    var currentIntersected= undefined;    var setWellInfo = function (well_name){        $.each(editor.sceneHelpers.children,function(i,v){            if (v.obj_type === 'well_label' && v.name === well_name){                v.scale.set(10,5,1.0);            }            if (v.obj_type === 'well_value_point' && v.name === well_name){                v.scale.set(0.4,0.4,1.0);            }            if (v.obj_type === 'well_start' && v.name === well_name){                v.scale.set(4,4,1.0);            }            if (v.obj_type === 'well_value_label' && v.name === well_name){                v.visible= true;            }        });    };    var revertWellInfo = function (){        $.each(editor.sceneHelpers.children,function(i,v){            if (v.obj_type === 'well_label' ){                v.scale.set(4,2,1.0);            }            if ( v.obj_type === 'well_value_point' ){                v.scale.set(0.2,0.2,1.0);            }            if (v.obj_type === 'well_start'){                v.scale.set(2,2,1.0);            }            if (v.obj_type === 'well_value_label'){                v.visible= false;            }        });    };    var onselectMouseMove = function ( event ) {        event.preventDefault();        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseMovePosition.set( x, y );        var intersects = getIntersects( event, objects );        //console.log(intersects.length);        if ( intersects.length > 0 ) {            var position = intersects[ 0 ].point.clone();            var position_x = position.x.toFixed(2);            var position_y = position.y.toFixed(2);            var position_z = position.z.toFixed(2);            info.setValue("x:" + position_x + ", y:" + position_y + ", z:" + position_z);            //console.log(position);            if ( currentIntersected !== undefined ) {                currentIntersected.material.linewidth = currentIntersected.real || 2;                revertWellInfo();            }            if (intersects[ 0 ].object.obj_type === 'well') {                currentIntersected = intersects[ 0 ].object;                currentIntersected.material.linewidth = 5;               // var position = intersects[ 0 ].point.clone();//                console.log('bb');                //currentIntersected.material.name='aaa';                //currentIntersected.material.color=0xffffff;                //sphereInter.visible = true;                //sphereInter.position.copy( intersects[ 0 ].point );            }else if(intersects[ 0 ].object.obj_type === 'line') {                currentIntersected = intersects[ 0 ].object;                currentIntersected.material.linewidth = 5;                //console.log(intersects[ 0 ].object.obj_type);                revertWellInfo();            }else{                revertWellInfo();                //console.log(intersects[ 0 ].object.obj_type);            }        } else {            info.setValue("x:0, y:0, z:0");            if ( currentIntersected !== undefined ) {                currentIntersected.material.linewidth = currentIntersected.real || 2;                revertWellInfo();            }            currentIntersected = undefined;            tmpLine.visible = false;            sphereInter.visible = false;            //sphereInter.visible = false;        }        render();    };    var ondrawMouseMove = function ( event ) {        event.preventDefault();        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseMovePosition.set( x, y );        var intersects = getIntersects( event, objects );        if ( intersects.length > 0 ) {            var position = intersects[ 0 ].point.clone();            var position_x = position.x.toFixed(2);            var position_y = position.y.toFixed(2);            var position_z = position.z.toFixed(2);            info.setValue("x:" + position_x + ", y:" + position_y + ", z:" + position_z);            //if (intersects[ 0 ].object.obj_type === 'well')            //{                if ( currentIntersected !== undefined ) {                    currentIntersected.material.linewidth = currentIntersected.real || 2;                    revertWellInfo();                }                currentIntersected = intersects[ 0 ].object;                if (currentIntersected.obj_type === "helper_plane"){                    if (intersects[ 1 ] !== undefined && intersects[ 1 ].object.obj_type === 'well'){                        currentIntersected = intersects[ 1 ].object;                        sphereInter.material.color.r=1;                        sphereInter.material.color.b=0;                        setWellInfo(currentIntersected.name);                    }else{                        sphereInter.material.color.r=0;                        sphereInter.material.color.b=1;                    }                }else if (currentIntersected.obj_type === "well"){                    sphereInter.material.color.r=1;                    sphereInter.material.color.b=0;                    setWellInfo(currentIntersected.name);                }else{                    revertWellInfo();                }                currentIntersected.material.linewidth = 3;                //currentIntersected.material.name='aaa';                //currentIntersected.material.color=0xffffff;                if (draw_line !== undefined && draw_line.geometry.vertices.length > 0){                    tmpLine.visible = true;                    tmpLine.geometry.vertices=[draw_line.geometry.vertices[draw_line.geometry.vertices.length-1].clone(),intersects[ 0 ].point.clone()];                }                sphereInter.visible = true;                sphereInter.position.copy( intersects[ 0 ].point );            //}        } else {            info.setValue("x:0, y:0, z:0");            if ( currentIntersected !== undefined ) {                currentIntersected.material.linewidth = currentIntersected.real || 2;                revertWellInfo();            }            currentIntersected = undefined;            tmpLine.visible = false;            sphereInter.visible = false;        }        render();    };	var onselectMouseDown = function ( event ) {		event.preventDefault();		var rect = container.dom.getBoundingClientRect();		x = (event.clientX - rect.left) / rect.width;		y = (event.clientY - rect.top) / rect.height;		onMouseDownPosition.set( x, y );		document.addEventListener( 'mouseup', onselectMouseUp, false );	};	var onselectMouseUp = function ( event ) {		var rect = container.dom.getBoundingClientRect();		x = (event.clientX - rect.left) / rect.width;		y = (event.clientY - rect.top) / rect.height;		onMouseUpPosition.set( x, y );		if ( onMouseDownPosition.distanceTo( onMouseUpPosition ) == 0 ) {			var intersects = getIntersects( event, objects );			if ( intersects.length > 0 ) {				var object = intersects[ 0 ].object;				if ( object.userData.object !== undefined ) {					// helper					editor.select( object.userData.object );				} else {					editor.select( object );				}			} else {				editor.select( null );			}			render();		}		document.removeEventListener( 'mouseup', onselectMouseUp );	};	var onselectDoubleClick = function ( event ) {		var intersects = getIntersects( event, objects );		if ( intersects.length > 0 && intersects[ 0 ].object === editor.selected ) {			controls.focus( editor.selected );		}	};    var ondrawMouseDown = function ( event ) {        event.preventDefault();        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseDownPosition.set( x, y );        document.addEventListener( 'mouseup', ondrawMouseUp, false );    };    var ondrawMouseUp = function ( event ) {        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseUpPosition.set( x, y );        if ( onMouseDownPosition.distanceTo( onMouseUpPosition ) == 0 ) {            var intersects = getIntersects( event, objects );            if ( intersects.length > 0 ) {                var focus = new THREE.Vector3();                if (intersects[ 0 ].object.obj_type === "helper_plane" &&                    intersects[ 1 ] !== undefined &&                    intersects[ 1 ].object.obj_type === 'well') {                    focus=intersects[ 1 ].point.clone();                }else{                    focus=intersects[ 0 ].point.clone();                }                //var point = new THREE.Vector3();                //point.copy(intersects[ 0 ].point);                if(draw_line !== undefined){                    draw_line.geometry.vertices.push(focus);                }else{                    //console.log('new');                    //draw_line_init_point = new THREE.Vector3();                    draw_line_init_point = focus;                    var geometry = new THREE.Geometry();                    //geometry.vertices.length = 0;                    geometry.vertices.push( focus );                    draw_line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xffffff,linewidth: 2 } ), THREE.LineStrip );                    draw_line.name ='line' + ( ++ editor.draw_line_count );                    draw_line.obj_type = 'line';                    editor.addObject(draw_line);                }            } else {            }            render();        }        document.removeEventListener( 'mouseup', ondrawMouseUp );    };    var ondrawDoubleClick = function ( event ) {        if (draw_line.geometry.vertices.length < 2){            editor.removeObject(draw_line);            draw_line=undefined;        }else{            if (draw_line_init_point !== undefined){                draw_line.geometry.vertices.push(draw_line_init_point);                draw_line.geometry.computeBoundingSphere();                //保存线                var post_data= {};                post_data.points=draw_line.geometry.vertices;                $.ajax({                    type: "POST", //访问WebService使用Post方式请求                    contentType: "application/json", //WebService 会返回Json类型                    url: "../getdata/saveline.json", //调用WebService的地址和方法名称组合 ---- WsURL/方法名                    data: $.toJSON(post_data), //这里是要传递的参数，格式为 data: "{paraName:paraValue}",下面将会看到                    dataType: 'json',                    success: function (res){                        if (res.result){                            draw_line.obj_id = res.line_id;                        }else{                            editor.removeObject(draw_line);                            alert(res.message);                        }                    },                    complete: function (res){                        draw_line=undefined;                    }                });            }        }        draw_line_init_point = undefined;        tmpLine.visible = false;        sphereInter.visible = false;        signals.operModeChanged.dispatch( 'select' );        render();    };    var onmeasureMouseDown = function ( event ) {        event.preventDefault();        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseDownPosition.set( x, y );        document.addEventListener( 'mouseup', onmeasureMouseUp, false );    };    var onmeasureMouseUp = function ( event ) {        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseUpPosition.set( x, y );        if ( onMouseDownPosition.distanceTo( onMouseUpPosition ) == 0 ) {            var intersects = getIntersects( event, objects );            if ( intersects.length > 0 ) {                var focus = new THREE.Vector3();                if (intersects[ 0 ].object.obj_type === "helper_plane" &&                    intersects[ 1 ] !== undefined &&                    intersects[ 1 ].object.obj_type === 'well') {                    focus=intersects[ 1 ].point.clone();                }else{                    focus=intersects[ 0 ].point.clone();                }                //var point = new THREE.Vector3();                //point.copy(intersects[ 0 ].point);                if(draw_line !== undefined){                    draw_line.geometry.vertices.push(focus);                }else{                    //console.log('new');                    //draw_line_init_point = new THREE.Vector3();                    draw_line_init_point = focus;                    var geometry = new THREE.Geometry();                    //geometry.vertices.length = 0;                    geometry.vertices.push( focus );                    draw_line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xffffff,linewidth: 2 } ), THREE.LineStrip );                    //draw_line.name ='line' + ( ++ editor.draw_line_count );                    //draw_line.obj_type = 'line';                    //editor.addObject(draw_line);                }            } else {            }            render();        }        document.removeEventListener( 'mouseup', onmeasureMouseUp );    };    var onmeasureMouseMove = function ( event ) {        event.preventDefault();        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseMovePosition.set( x, y );        var intersects = getIntersects( event, objects );        if ( intersects.length > 0 ) {            var position = intersects[ 0 ].point.clone();            var position_x = position.x.toFixed(2);            var position_y = position.y.toFixed(2);            var position_z = position.z.toFixed(2);            info.setValue("x:" + position_x + ", y:" + position_y + ", z:" + position_z);            //if (intersects[ 0 ].object.obj_type === 'well')            //{            if ( currentIntersected !== undefined ) {                currentIntersected.material.linewidth = currentIntersected.real || 2;                revertWellInfo();            }            currentIntersected = intersects[ 0 ].object;            if (currentIntersected.obj_type === "helper_plane"){                if (intersects[ 1 ] !== undefined && intersects[ 1 ].object.obj_type === 'well'){                    currentIntersected = intersects[ 1 ].object;                    sphereInter.material.color.r=1;                    sphereInter.material.color.b=0;                    setWellInfo(currentIntersected.name);                }else{                    sphereInter.material.color.r=0;                    sphereInter.material.color.b=1;                }            }else if (currentIntersected.obj_type === "well"){                sphereInter.material.color.r=1;                sphereInter.material.color.b=0;                setWellInfo(currentIntersected.name);            }else{                revertWellInfo();            }            currentIntersected.material.linewidth = 3;            //currentIntersected.material.name='aaa';            //currentIntersected.material.color=0xffffff;            if (draw_line !== undefined && draw_line.geometry.vertices.length > 0){                tmpLine.visible = true;                tmpLine.geometry.vertices=[draw_line.geometry.vertices[draw_line.geometry.vertices.length-1].clone(),intersects[ 0 ].point.clone()];//                measure.setValue(draw_line.geometry.vertices[draw_line.geometry.vertices.length-1].x);                console.log(draw_line.geometry.vertices.length);                var startPoint = draw_line.geometry.vertices[draw_line.geometry.vertices.length-1].clone();                var endPoint = intersects[ 0 ].point.clone();                //var theta = Math.atan(Math.abs(endPoint.z - startPoint.z)/Math.abs(endPoint.x - startPoint.x)) * 180 / Math.PI;                var decline = Math.atan(Math.abs(endPoint.y - startPoint.y)/Math.sqrt((endPoint.z - startPoint.z)                    * (endPoint.z - startPoint.z)  + (endPoint.x - startPoint.x)  * (endPoint.x - startPoint.x))) * 180 / Math.PI;                var distance = Math.sqrt((endPoint.x - startPoint.x) * (endPoint.x - startPoint.x) + (endPoint.y - startPoint.y) * (endPoint.y - startPoint.y) + (endPoint.z - startPoint.z)                    * (endPoint.z - startPoint.z));                ///////////////////////////////////////////////20150428                 if(endPoint.y < startPoint.y){                    decline = -decline;                }                var tan_theta = (endPoint.z - startPoint.z)/(endPoint.x - startPoint.x);                var theta = Math.atan((endPoint.z - startPoint.z)/(endPoint.x - startPoint.x)) * 180 / Math.PI;                //var new_theta = theta;                var cos_theta = (endPoint.x - startPoint.x) / Math.sqrt((endPoint.x - startPoint.x) * (endPoint.x - startPoint.x) + (endPoint.z - startPoint.z) * (endPoint.z - startPoint.z));                var sin_theta = (endPoint.z - startPoint.z) / Math.sqrt((endPoint.x - startPoint.x) * (endPoint.x - startPoint.x) + (endPoint.z - startPoint.z) * (endPoint.z - startPoint.z));                var new_theta;                if(tan_theta >= 0 && cos_theta > 0){                    new_theta = Math.asin(sin_theta) * 180 / Math.PI;                }                else if((endPoint.x - startPoint.x) ==0 && sin_theta == 1){                    new_theta = 90;                }                else if(tan_theta < 0 && cos_theta < 0){                    new_theta = 180 - Math.asin(sin_theta) * 180 / Math.PI;                }                else if(tan_theta == 0 && cos_theta == -1){                    new_theta = 180;                }                else if(tan_theta > 0 && cos_theta < 0){                    new_theta = Math.abs(theta) + 180;                }                else if((endPoint.x - startPoint.x) ==0 && sin_theta == -1){                    new_theta = 270;                }                else if(tan_theta < 0 && cos_theta > 0){                    theta = Math.atan(Math.abs(endPoint.x - startPoint.x)/Math.abs(endPoint.z - startPoint.z)) * 180 / Math.PI;                    new_theta = Math.abs(theta) + 270;                }                var f_distance = Math.sqrt((endPoint.z - startPoint.z) *(endPoint.z - startPoint.z) + (endPoint.x - startPoint.x) * (endPoint.x - startPoint.x));                f_distance = f_distance.toFixed(2);                ///////////////////////////////////////////////////////////                new_theta = new_theta.toFixed(2);                decline = decline.toFixed(2);                distance = distance.toFixed(2);                measure.setValue("方位角：" + new_theta + ", 倾角：" + decline + ", 空间距离：" + distance + ", 投影距离" + f_distance);                //measure.setValue("方位角：" + tan_theta + ", 倾角：" + sin_theta + ", 距离：" + cos_theta);               // measure.setValue("方位角：" + theta + ", 倾角：" + Math.asin(sin_theta)*180/Math.PI + ", 距离：" + Math.acos(cos_theta)*180/Math.PI);            }            sphereInter.visible = true;            sphereInter.position.copy( intersects[ 0 ].point );            //}        } else {            info.setValue("x:0, y:0, z:0");            measure.setValue( '方位角: 0,倾角: 0, 空间距离: 0, 投影距离：0' );            if ( currentIntersected !== undefined ) {                currentIntersected.material.linewidth = currentIntersected.real || 2;                revertWellInfo();            }            currentIntersected = undefined;            tmpLine.visible = false;            sphereInter.visible = false;        }        render();    };    var onmeasureDoubleClick = function ( event ) {//        editor.removeObject(draw_line);        draw_line=undefined;        draw_line_init_point = undefined;        tmpLine.visible = false;        sphereInter.visible = false;        measure.setDisplay('none');        signals.operModeChanged.dispatch( 'select' );        render();    };    ////////////////////////////////////////////////孤立点    var onparticleMouseDown = function ( event ) {        event.preventDefault();        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseDownPosition.set( x, y );        console.log('come in particle');        document.addEventListener( 'mouseup', onparticleMouseUp, false );    };    var onparticleMouseUp = function ( event ) {        console.log("comme in particle");        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseUpPosition.set( x, y );        if ( onMouseDownPosition.distanceTo( onMouseUpPosition ) == 0 ) {            var intersects = getIntersects( event, objects );            if ( intersects.length > 0 ) {                var focus = new THREE.Vector3();                if (intersects[ 0 ].object.obj_type === "helper_plane" &&                    intersects[ 1 ] !== undefined &&                    intersects[ 1 ].object.obj_type === 'well') {                    focus=intersects[ 1 ].point.clone();                }else{                    focus=intersects[ 0 ].point.clone();                }                var particles = new THREE.Geometry();                var pMaterial = new THREE.ParticleBasicMaterial({color: 0xffffff, size:20, opacity: 0.1});                var particle = focus.clone();                //console.log(particle);                    //particles.vertices.push(particle);                particles.vertices.push(particle);                    //console.log(particles);                draw_particle = new THREE.ParticleSystem(particles, pMaterial);                draw_particle.obj_type = 'particle';                editor.addObject(draw_particle);                console.log(draw_particle);                //console.log(draw_particle.position);                    //scene.add(draw_particle);                    draw_particle_init_point = focus;                    var geometry = new THREE.Geometry();                    //geometry.vertices.length = 0;                    geometry.vertices.push( focus );                    console.log(focus);                    draw_particle = new THREE.ParticleSystem( geometry, new THREE.ParticleBasicMaterial( { color: 0xffffff,size: 20 } ) );                    //draw_line.name ='line' + ( ++ editor.draw_line_count );                    draw_particle.obj_type = 'particle';                    editor.addObject(draw_particle);            } else {            }            render();        }        document.removeEventListener( 'mouseup', onparticleMouseUp );    };    var onparticleMouseMove = function ( event ) {        event.preventDefault();        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseMovePosition.set( x, y );        var intersects = getIntersects( event, objects );        if ( intersects.length > 0 ) {            var position = intersects[ 0 ].point.clone();            var position_x = position.x.toFixed(2);            var position_y = position.y.toFixed(2);            var position_z = position.z.toFixed(2);            info.setValue("x:" + position_x + ", y:" + position_y + ", z:" + position_z);            //if (intersects[ 0 ].object.obj_type === 'well')            //{            if ( currentIntersected !== undefined ) {                currentIntersected.material.linewidth = currentIntersected.real || 2;                revertWellInfo();            }            currentIntersected = intersects[ 0 ].object;            if (currentIntersected.obj_type === "helper_plane"){                if (intersects[ 1 ] !== undefined && intersects[ 1 ].object.obj_type === 'well'){                    currentIntersected = intersects[ 1 ].object;                    sphereInter.material.color.r=1;                    sphereInter.material.color.b=0;                    setWellInfo(currentIntersected.name);                }else{                    sphereInter.material.color.r=0;                    sphereInter.material.color.b=1;                }            }else if (currentIntersected.obj_type === "well"){                sphereInter.material.color.r=1;                sphereInter.material.color.b=0;                setWellInfo(currentIntersected.name);            }else{                revertWellInfo();            }            currentIntersected.material.linewidth = 3;            //currentIntersected.material.name='aaa';            //currentIntersected.material.color=0xffffff;            if (draw_line !== undefined && draw_line.geometry.vertices.length > 0){                tmpLine.visible = true;                tmpLine.geometry.vertices=[draw_line.geometry.vertices[draw_line.geometry.vertices.length-1].clone(),intersects[ 0 ].point.clone()];            }            sphereInter.visible = true;            sphereInter.position.copy( intersects[ 0 ].point );            //}        } else {            info.setValue("x:0, y:0, z:0");            if ( currentIntersected !== undefined ) {                currentIntersected.material.linewidth = currentIntersected.real || 2;                revertWellInfo();            }            currentIntersected = undefined;            tmpLine.visible = false;            sphereInter.visible = false;        }        render();    };    var onparticleDoubleClick = function ( event) {        console.log('dbclick');        draw_particle = undefined;        draw_particle_init_point = undefined;        signals.operModeChanged.dispatch('select');        render();    }    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////辅助面    var onplaneMouseDown = function ( event ) {        event.preventDefault();        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseDownPosition.set( x, y );        document.addEventListener( 'mouseup', onplaneMouseUp, false );    };    var onplaneMouseUp = function ( event ) {        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseUpPosition.set( x, y );        if ( onMouseDownPosition.distanceTo( onMouseUpPosition ) == 0 ) {            var intersects = getIntersects( event, objects );            if ( intersects.length > 0 ) {                var focus = new THREE.Vector3();                if(intersects[ 0 ].object.obj_type === "helper_plane" ||intersects[ 0 ].object.obj_type === "horizontal_plane" || intersects[0].object.obj_type === "line" &&                    intersects[ 1 ] !== undefined &&                    intersects[ 1 ].object.obj_type === 'well')                {                //if (intersects[ 0 ].object.obj_type === "horizontal_plane" || intersects[0].object.obj_type === "helper_plane" || intersects[0].object.obj_type === "line") {                    focus=intersects[ 0 ].point.clone();                    if(time == 0){                        start_helperPlane = focus;                        //console.log(start_helperPlane);                        time = 1;                    }                    else {                        end_helperPlane = focus;                        //console.log(end_helperPlane);                        signals.operModeChanged.dispatch( 'select' );                    }                }                if(draw_line !== undefined){                    draw_line.geometry.vertices.push(focus);                }else{                    //console.log('new');                    //draw_line_init_point = new THREE.Vector3();                    draw_line_init_point = focus;                    var geometry = new THREE.Geometry();                    //geometry.vertices.length = 0;                    geometry.vertices.push( focus );                    draw_line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xffffff,linewidth: 2 } ), THREE.LineStrip );                    //draw_line.name ='line' + ( ++ editor.draw_line_count );                    //draw_line.obj_type = 'line';                    //editor.addObject(draw_line);                }            } else {            }            render();        }        document.removeEventListener( 'mouseup', onplaneMouseUp );    };    var onplaneMouseMove = function ( event ) {        event.preventDefault();        var rect = container.dom.getBoundingClientRect();        x = (event.clientX - rect.left) / rect.width;        y = (event.clientY - rect.top) / rect.height;        onMouseMovePosition.set( x, y );        var intersects = getIntersects( event, objects );        if ( intersects.length > 0 ) {            var position = intersects[ 0 ].point.clone();            var position_x = position.x.toFixed(2);            var position_y = position.y.toFixed(2);            var position_z = position.z.toFixed(2);            info.setValue("x:" + position_x + ", y:" + position_y + ", z:" + position_z);            //if (intersects[ 0 ].object.obj_type === 'well')            //{            if ( currentIntersected !== undefined ) {                currentIntersected.material.linewidth = currentIntersected.real || 2;                revertWellInfo();            }            currentIntersected = intersects[ 0 ].object;            if (currentIntersected.obj_type === "horizontal_plane"){                if (intersects[ 1 ] !== undefined && intersects[ 1 ].object.obj_type === 'well'){                    currentIntersected = intersects[ 1 ].object;                    sphereInter.material.color.r=1;                    sphereInter.material.color.b=0;                    setWellInfo(currentIntersected.name);                }else{                    sphereInter.material.color.r=0;                    sphereInter.material.color.b=1;                }            }else if (currentIntersected.obj_type === "well"){                sphereInter.material.color.r=1;                sphereInter.material.color.b=0;                setWellInfo(currentIntersected.name);            }else{                revertWellInfo();            }            currentIntersected.material.linewidth = 3;            //currentIntersected.material.name='aaa';            //currentIntersected.material.color=0xffffff;            if (draw_line !== undefined && draw_line.geometry.vertices.length > 0){                tmpLine.visible = true;                tmpLine.geometry.vertices=[draw_line.geometry.vertices[draw_line.geometry.vertices.length-1].clone(),intersects[ 0 ].point.clone()];            }            sphereInter.visible = true;            sphereInter.position.copy( intersects[ 0 ].point );        } else {            info.setValue("x:0, y:0, z:0");            //measure.setValue("方位角：0，倾角：0，距离：0");            if ( currentIntersected !== undefined ) {                currentIntersected.material.linewidth = currentIntersected.real || 2;                revertWellInfo();            }            currentIntersected = undefined;            tmpLine.visible = false;            sphereInter.visible = false;        }        render();    };////////////////////////////////////////////////////////////////////////////    container.dom.addEventListener( 'mousedown', onselectMouseDown, false );    container.dom.addEventListener( 'dblclick', onselectDoubleClick, false );    container.dom.addEventListener( 'mousemove', onselectMouseMove, false );	// controls need to be added *after* main logic,	// otherwise controls.enabled doesn't work.	// signals    //////////////////////////////////////////////0501转换相机    signals.changeCamera.add(function(value){        var near = camera.near;        var far = camera.far;        if(value === "perspective_camera"){            var camera_perspective = THREE.PerspectiveCamera(50, 1, near, far);            camera = camera_perspective;        }        else if(value === "orthographic_camera"){            var camera_orthographic = THREE.OrthographicCamera();            THREE.Camera.prototype.clone.call(this, camera_orthographic);            camera = camera_orthographic;        }    });    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////视角    signals.viewChanged.add(function(value){        var target = controls.center;        var position = camera.position;        var camera_position_x;        var camera_position_y;        var camera_position_z;        //var position_initial = position;        //console.log(target);        //console.log(position);        var distance =Math.sqrt((position.x - target.x) * (position.x - target.x) + (position.y - target.y) * (position.y - target.y)            + (position.z - target.z) * (position.z - target.z));        //console.log(distance);        if(value === "camera_front"){            camera_position_x = target.x;            camera_position_y = target.y;            camera_position_z = target.z + distance;            //camera.up.y = 1;            console.log(camera.up);        }        else if(value === "camera_back"){            camera_position_x = target.x;            camera_position_y = target.y;            camera_position_z = target.z - distance;            //camera.up.y = 1;        }        else if(value === "camera_left"){            camera_position_x = target.x - distance;            camera_position_y = target.y;            camera_position_z = target.z;            //camera.up.y = 1;        }        else if (value === "camera_right"){            camera_position_x = target.x + distance;            camera_position_y = target.y;            camera_position_z = target.z;            //camera.up.z = 1;        }        else if(value === "camera_above"){            camera_position_x = target.x;            camera_position_y = target.y;            camera_position_z = target.z + distance;            //camera.rotation.y = Math.PI;            //camera.up.x = 1;            //camera.updateProjectionMatrix();            console.log(camera.up);        }        else if (value === "camera_below"){            camera_position_x = target.x;            camera_position_y = target.y - distance;            camera_position_z = target.z;            //camera.up.x = 1;        }        else if(value === "camera_initial"){            camera.position.fromArray(editor.config.getKey( 'camera_initial' ).position);            camera.lookAt( new THREE.Vector3().fromArray( editor.config.getKey( 'camera_initial' ).target ) );            //console.log(camera.up);            signals.cameraChanged.dispatch(camera);            return;        }        var camera_position = [camera_position_x, camera_position_y, camera_position_z];        camera.position.fromArray( camera_position );        camera.lookAt(target);        //controls.center = target;        signals.cameraChanged.dispatch(camera);        render();    });/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////辅助面    ////////正视角面对辅助面    /////////////////////////////////////////////////////0402    signals.helpPlaneChanged.add(function(target, width, cameraNear, cameraFar) {        //target 是辅助面形心数组，width是辅助面宽，height是辅助面高，value是正视或后视        //var theta =  Math.atan((Math.abs(end_helperPlane.z - start_helperPlane.z)) / (Math.abs(end_helperPlane.x - start_helperPlane.x)));        var theta_cos = Math.abs(start_helperPlane.x - end_helperPlane.x) / width;        //var theta = Math.acos(theta_cos);        var theta;        //console.log(theta);        //////////////////////////////////20150503修改        var distance = 80;        /////////////////////////////////////////////        if((start_helperPlane.x - end_helperPlane.x) * (start_helperPlane.z - end_helperPlane.z) > 0){            theta = Math.PI - Math.acos(theta_cos);            var camera_position_z = target[2] - theta_cos * distance;            var camera_position_y = target[1];            var camera_position_x = Math.sqrt((distance * distance) - (theta_cos * distance) * (theta_cos * distance)) + target[0];        }        else if((start_helperPlane.x - end_helperPlane.x) * (start_helperPlane.z - end_helperPlane.z) <= 0){            theta = Math.acos(theta_cos);            var camera_position_z = theta_cos * distance + target[2];            var camera_position_y = target[1];            var camera_position_x = Math.sqrt((distance * distance) - (theta_cos * distance) * (theta_cos * distance)) + target[0];        }        //var distance = width / ( 2 * (Math.tan(50 * 2 * Math.PI / 360)));        var camera_position = [camera_position_x, camera_position_y, camera_position_z];        ////////////////////////////////////////////////////////////20150503修改        if(cameraNear !==0 && cameraFar !== 0){            camera.near = distance - cameraNear;            camera.far = distance + cameraFar;        }        else if (cameraNear !== 0){            camera.near = distance - cameraNear;        }        else if(cameraFar !== 0){            camera.far = distance + cameraFar;        }        ////////////////////////////////////////////////////////////////////////        camera.updateProjectionMatrix();        camera.position.fromArray(camera_position);        camera.lookAt(new THREE.Vector3().fromArray(target));        controls.center.fromArray(target);        signals.cameraChanged.dispatch(camera);        controls.changeState('disable rotate');        controls.changeMatrix(1,cameraNear,cameraFar);        render();    });    ////////////////////////////////////////////////////////////////////////////0402    ////反向查看辅助面    signals.helperPlaneReverse.add(function(value){        //var target = controls.center.toArray;        var target = [0.5 * (end_helperPlane.x + start_helperPlane.x), -0.5 * value, 0.5 * (end_helperPlane.z + start_helperPlane.z)];        //console.log('target:'+ target);        var position_0 = camera.position.toArray();        //console.log(position_0);        var position_x = 2 * target[0] - position_0[0];        var position_y = 2 * target[1] - position_0[1]        var position_z = 2 * target[2] - position_0[2];        var position = [position_x, position_y, position_z];        //console.log('position:' + position);        camera.position.fromArray(position);        camera.lookAt(new THREE.Vector3().fromArray(target));        signals.cameraChanged.dispatch( camera );        render();    });    /////取消不能旋转功能，重新设置相机的最大距离和最小距离    signals.helperPlaneReturn.add(function(){          //辅助面返回模式        controls.changeState('rotate');        ////////////////////////////////////////0330        camera.near = 1;        camera.far = 50000;        camera.updateProjectionMatrix();        controls.changeMatrix(0, camera.near, camera.far);        //////////////////////////////////////0330        render();    });    //////创建辅助面    signals.helperPlaneCreate.add(function(value){        //signals.operModeChanged.dispatch('plane');        ///////获取辅助面的高度和宽度        var width = Math.sqrt((end_helperPlane.z - start_helperPlane.z) * (end_helperPlane.z - start_helperPlane.z)            + (end_helperPlane.x - start_helperPlane.x) * (end_helperPlane.x - start_helperPlane.x));        var height = value;        /////////////////////////////////////////////0401修改        var geometry = new THREE.PlaneGeometry(width * 2, height, 10, 10);        ////////////////////////////////////////////0401修改        var material = new THREE.MeshBasicMaterial({ color: 0x00ff00,  opacity: 0.1, transparent: true,side: THREE.DoubleSide  });        var mesh = new THREE.Mesh( geometry, material );        //var theta =  Math.atan((Math.abs(end_helperPlane.z - start_helperPlane.z)) / (Math.abs(end_helperPlane.x - start_helperPlane.x)));        var theta_cos = Math.abs(start_helperPlane.x - end_helperPlane.x) / width;        var theta = Math.acos(theta_cos);        if((start_helperPlane.x - end_helperPlane.x) * (start_helperPlane.z - end_helperPlane.z) < 0){            mesh.rotation.y = theta;        }        else {            mesh.rotation.y = Math.PI - theta;        }        mesh.position.x = 0.5 * (start_helperPlane.x + end_helperPlane.x);        mesh.position.y = -0.5 * height;        mesh.position.z = 0.5 * (start_helperPlane.z + end_helperPlane.z);        mesh.name = 'p' + ( ++ meshCount );        mesh.obj_type = 'helper_plane';        editor.addObject( mesh );        ///转换视角        //signals.helpPlaneChanged()        var target = [mesh.position.x, mesh.position.y, mesh.position.z];        signals.helpPlaneChanged.dispatch(target, width, 0, 0);        render();    });/////////////////////////////////////////////////////////////////////////////////    /////////////////////////////////////////////////////////////////////0401    //////////////////////////////////////////////工作面上下移动    signals.helperPlaneUpDown.add(function(value){        var move = 0;        if(value === 'up'){            //console.log(editor.select.object);            move = 50;        }        else if(value === 'down'){            move = -50;        }        var position_camera = [camera.position.x, camera.position.y + move, camera.position.z];        var target = [controls.center.x, controls.center.y + move, controls.center.z];        camera.position.fromArray(position_camera);        camera.lookAt(new THREE.Vector3().fromArray(target));        controls.center.fromArray(target);        signals.cameraChanged.dispatch( camera );        render();    });     /* signals.helperPlaneWidthChange(function(value){        if(value === 'add'){        }        else if (value === 'reduce'){        }    });*/    ////////////////////////////////////////////////////////////////////0401	signals.themeChanged.add( function ( value ) {		switch ( value ) {		    case '../Styles/editor/light.css':				grid.setColors( 0x444444, 0x888888 );				clearColor = 0xaaaaaa;				break;			case '../Styles/editor/dark.css':				grid.setColors( 0xbbbbbb, 0x888888 );				clearColor = 0x333333;				break;		}		renderer.setClearColor( clearColor );		render();	} );	signals.transformModeChanged.add( function ( mode ) {		transformControls.setMode( mode );	} );////////////////////////////////////////////////////////////////////辅助面,添加孤立点    signals.operModeChanged.add( function ( mode ) {        operMode = mode ;        container.dom.removeEventListener( 'mousedown', onselectMouseDown,false );        container.dom.removeEventListener( 'dblclick', onselectDoubleClick, false );        container.dom.removeEventListener( 'mousemove', onselectMouseMove, false );        container.dom.removeEventListener( 'mousedown', ondrawMouseDown, false );        container.dom.removeEventListener( 'dblclick', ondrawDoubleClick, false );        container.dom.removeEventListener( 'mousemove', ondrawMouseMove, false );        container.dom.removeEventListener( 'mousedown', onmeasureMouseDown, false );        container.dom.removeEventListener( 'dblclick', onmeasureDoubleClick, false );        container.dom.removeEventListener( 'mousemove', onmeasureMouseMove, false );        container.dom.removeEventListener( 'mousedown', onplaneMouseDown, false );        container.dom.removeEventListener( 'dblclick', onmeasureDoubleClick, false );        container.dom.removeEventListener( 'mousemove', onplaneMouseMove, false );        container.dom.removeEventListener( 'mousemove', onparticleMouseMove, false);        container.dom.removeEventListener( 'mousedown', onparticleMouseDown, false );        container.dom.removeEventListener( 'dblclick', onparticleDoubleClick, false );        switch (operMode){            case 'select':                container.dom.addEventListener( 'mousedown', onselectMouseDown, false );                container.dom.addEventListener( 'dblclick', onselectDoubleClick, false );                container.dom.addEventListener( 'mousemove', onselectMouseMove, false );                break;            case 'draw_line':                container.dom.addEventListener( 'mousedown', ondrawMouseDown, false );                container.dom.addEventListener( 'dblclick', ondrawDoubleClick, false );                container.dom.addEventListener( 'mousemove', ondrawMouseMove, false );                break;            case 'measure':                container.dom.addEventListener( 'mousedown', onmeasureMouseDown, false );                container.dom.addEventListener( 'dblclick', onmeasureDoubleClick, false );                container.dom.addEventListener( 'mousemove', onmeasureMouseMove, false );                measure.setValue("方位角: 0,倾角: 0, 距离: 0");                measure.setDisplay("inline-block");                break;            case 'plane':                container.dom.addEventListener( 'mousedown', onplaneMouseDown, false );                container.dom.addEventListener( 'mousemove', onplaneMouseMove, false );                //container.dom.addEventListener('dblclick', onparticleDoubleClick, false);                break;            case 'particle':                container.dom.addEventListener( 'mousedown', onparticleMouseDown, false );                container.dom.addEventListener( 'dblclick', onparticleDoubleClick, false );                container.dom.addEventListener( 'mousemove', onparticleMouseMove, false );                break;            default :                container.dom.addEventListener( 'mousedown', onselectMouseDown, false );                container.dom.addEventListener( 'dblclick', onselectDoubleClick, false );                container.dom.addEventListener( 'mousemove', onselectMouseMove, false );        }    } );    /////////////////////////////////////////////////////////////////////////////////////////////////////	signals.snapChanged.add( function ( dist ) {		transformControls.setSnap( dist );	} );    signals.gridChanged.add( function ( dist ) {        //sceneHelpers.remove( grid );        if (dist.view === false){            grid.visible=false;        }else{            grid = new THREE.GridHelper( dist.all,dist.cell );            sceneHelpers.children[0] = grid;        }//        controls = new THREE.EditorControls( camera, container.dom );//        controls.addEventListener( 'change', function () {////            transformControls.update();//            signals.cameraChanged.dispatch( camera );////        } );        render();    } );	signals.spaceChanged.add( function ( space ) {		transformControls.setSpace( space );	} );	signals.rendererChanged.add( function ( type ) {		container.dom.removeChild( renderer.domElement );		renderer = new THREE[ type ]( { antialias: true } );		renderer.autoClear = false;		renderer.autoUpdateScene = false;		renderer.setClearColor( clearColor );		renderer.setSize( container.dom.offsetWidth, container.dom.offsetHeight );		container.dom.appendChild( renderer.domElement );		render();	} );    signals.levelChanged.add( function ( level ) {        //console.log(level);        var levels = level.split("_");        $.each(editor.sceneHelpers.children,function(i,v){            if (v.obj_type === 'well_label' || v.obj_type === 'well_start' || v.obj_type === 'well_value_point' || v.obj_type === 'well_value_label') {                v.visible = false;                for(var i = 0; i< levels.length; i++) {                    if (levels[i] == '1' || levels[i] == '0') {                        if (v.obj_type != 'well_value_label') {                            v.visible = true;                        }                    }                }             }        });        $.each(scene.children,function(i,obj){            obj.visible= false;            for(var i = 0; i< levels.length; i++){                switch (levels[i]){                    case '0':                        obj.visible=true;                        break;                    case '1':                        if (obj.obj_type === 'well') { obj.visible=true;}                        break;                    case '2':                        if (obj.obj_type === 'line') { obj.visible=true;}                        break;                    case '3':                        if (obj.obj_type === 'object') { obj.visible=true;}                        break;                }            }        });        render();    } );	signals.sceneGraphChanged.add( function () {		render();		updateInfo();	} );	var saveTimeout;	signals.cameraChanged.add( function () {		if ( saveTimeout !== undefined ) {			clearTimeout( saveTimeout );		}		saveTimeout = setTimeout( function () {			editor.config.setKey( 'camera', {				position: camera.position.toArray(),				target: controls.center.toArray()			} );		}, 1000 );		render();	} );    signals.helpPlaneChanged.add(function(object){        if(object.geometry instanceof THREE.PlaneGeometry === true) {            console.log(object.geometry.center);            console.log(object.length);        }    });	signals.objectSelected.add( function ( object ) {		selectionBox.visible = false;		transformControls.detach();		if ( object !== null ) {//			if ( object.geometry !== undefined &&//				 object instanceof THREE.Sprite === false ) {//////				selectionBox.update( object );////				selectionBox.visible = true;////			}			if ( object.geometry !== undefined && object.geometry instanceof THREE.PlaneGeometry === true ) {                selectionBox.update( object );                selectionBox.visible = true;    			transformControls.attach( object );			}		}		render();	} );	signals.objectAdded.add( function ( object ) {		var materialsNeedUpdate = false;		object.traverse( function ( child ) {			if ( child instanceof THREE.Light ) materialsNeedUpdate = true;			objects.push( child );		} );		if ( materialsNeedUpdate === true ) updateMaterials();	} );	signals.objectChanged.add( function ( object ) {		transformControls.update();		if ( object !== camera ) {			if ( object.geometry !== undefined ) {//				selectionBox.update( object );			}			if ( editor.helpers[ object.id ] !== undefined ) {				editor.helpers[ object.id ].update();			}			updateInfo();		}		render();	} );	signals.objectRemoved.add( function ( object ) {		var materialsNeedUpdate = false;		object.traverse( function ( child ) {			if ( child instanceof THREE.Light ) materialsNeedUpdate = true;			objects.splice( objects.indexOf( child ), 1 );		} );		if ( materialsNeedUpdate === true ) updateMaterials();	} );	signals.helperAdded.add( function ( object ) {		objects.push( object.getObjectByName( 'picker' ) );	} );	signals.helperRemoved.add( function ( object ) {		objects.splice( objects.indexOf( object.getObjectByName( 'picker' ) ), 1 );	} );	signals.materialChanged.add( function ( material ) {		render();	} );	signals.fogTypeChanged.add( function ( fogType ) {		if ( fogType !== oldFogType ) {			if ( fogType === "None" ) {				scene.fog = null;			} else if ( fogType === "Fog" ) {				scene.fog = new THREE.Fog( oldFogColor, oldFogNear, oldFogFar );			} else if ( fogType === "FogExp2" ) {				scene.fog = new THREE.FogExp2( oldFogColor, oldFogDensity );			}			updateMaterials();			oldFogType = fogType;		}		render();	} );	signals.fogColorChanged.add( function ( fogColor ) {		oldFogColor = fogColor;		updateFog( scene );		render();	} );	signals.fogParametersChanged.add( function ( near, far, density ) {		oldFogNear = near;		oldFogFar = far;		oldFogDensity = density;		updateFog( scene );		render();	} );	signals.windowResize.add( function () {		camera.aspect = container.dom.offsetWidth / container.dom.offsetHeight;		camera.updateProjectionMatrix();		renderer.setSize( container.dom.offsetWidth, container.dom.offsetHeight );		render();	} );	signals.playAnimations.add( function (animations) {				function animate() {			requestAnimationFrame( animate );						for ( var i = 0; i < animations.length ; i ++ ) {				animations[i].update(0.016);			} 			render();		}		animate();	} );    /*signals.transformPerspective.add(function(){        //var camera = new THREE.PerspectiveCamera( 50, 1, 1, 50000 );        camera.position.fromArray( editor.config.getKey( 'camera_front' ).position );        camera.lookAt( new THREE.Vector3().fromArray( editor.config.getKey( 'camera_front' ).target ) );        alert("come in");        //transformControls.update(camera);        //render();    });*/	//	var clearColor, renderer;	if ( editor.config.getKey( 'renderer' ) !== undefined ) {		renderer = new THREE.WebGLRenderer( { antialias: true } );	} else {		if ( System.support.webgl === true && false ) {			renderer = new THREE.WebGLRenderer( { antialias: true } );		} else {			renderer = new THREE.CanvasRenderer();		}	}	renderer.autoClear = false;	renderer.autoUpdateScene = false;	container.dom.appendChild( renderer.domElement );	animate();	//	function updateInfo() {		var objects = 0;		var vertices = 0;		var faces = 0;		scene.traverse( function ( object ) {			if ( object instanceof THREE.Mesh ) {				objects ++;				var geometry = object.geometry;				if ( geometry instanceof THREE.Geometry ) {					vertices += geometry.vertices.length;					faces += geometry.faces.length;				} else if ( geometry instanceof THREE.BufferGeometry ) {					vertices += geometry.attributes.position.array.length / 3;					if ( geometry.attributes.index !== undefined ) {						faces += geometry.attributes.index.array.length / 3;					} else {						faces += geometry.attributes.position.array.length / 9;					}				}			}		} );		//info.setValue( '矿体: ' + objects + ', 矿井: ' + vertices + ', 块段: ' + faces );	}	function updateMaterials() {		editor.scene.traverse( function ( node ) {			if ( node.material ) {				node.material.needsUpdate = true;				if ( node.material instanceof THREE.MeshFaceMaterial ) {					for ( var i = 0; i < node.material.materials.length; i ++ ) {						node.material.materials[ i ].needsUpdate = true;					}				}			}		} );	}	function updateFog( root ) {		if ( root.fog ) {			root.fog.color.setHex( oldFogColor );			if ( root.fog.near !== undefined ) root.fog.near = oldFogNear;			if ( root.fog.far !== undefined ) root.fog.far = oldFogFar;			if ( root.fog.density !== undefined ) root.fog.density = oldFogDensity;		}	}	function animate() {		requestAnimationFrame( animate );	}	function render() {		sceneHelpers.updateMatrixWorld();		scene.updateMatrixWorld();		renderer.clear();		renderer.render( scene, camera );		if ( renderer instanceof THREE.RaytracingRenderer === false ) {			renderer.render( sceneHelpers, camera );		}	}	return container;}