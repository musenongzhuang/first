有关客户端与服务器json协议说明：

getdata目录中，为服务器传给客户端的数据实例
 1) GetWell.json-> 客户端获取钻井基本信息（不包括金属样本数据）的接口
 例子：
 wid->钻井数据库的id字段，唯一标示一个矿井
 no-> 矿井编号，也是矿井名称
 typec-> 矿井颜色，不同类型的矿井给不同的颜色就行
 real-> 对应矿井数据表中的real字段，表示矿井是计划中还是已经实施
 ps->  矿井拐点序列
 {"wid": "10","no": "n228","typec":"0x88ffff","real":true,"ps": [[50,0,-10], [51,-10,-11], [54,-25,-31], [50,-60,-11], [60,-65,-20]]}
 
 
 2) GetDetailWell.json-> 客户端获取钻井详细信息（包括金属样本数据）的接口
 例子：
 wid->钻井数据库的id字段，唯一标示一个矿井
 no-> 矿井编号，也是矿井名称
 real-> 对应矿井数据表中的real字段，表示矿井是计划中还是已经实施
 ps->  矿井金属样品段节点序列，其中前三个为x,y,z坐标，第四个数据为该段颜色（应该根据用户配置的不同浓度的颜色来配置，暂时可以先取一个固定值），第五个参数为该段样品的浓度值。
 {"wid": "10","no": "n228","real":true,"ps": [[50,0,-10,"0xffffff","0.25"], [51,-10,-11,"0xffffff","0.25"], [54,-25,-31,"0xffffff","0.25"], [50,-60,-11,"0xffffff","0.25"], [60,-65,-20,"0xffffff","0.25"]]}
 
 3) GetLine.json-> 客户端加载已保存的线圈的接口，直接从mongo数据库中取出数据即可。
 例子：
 {"lid": "2","name": "line2","ps": [[11,-1,10], [16,-10,15],[36,-10,15], [11,-1,10]]}

 lid-> 线圈在mongo数据库中的id（线圈只保存mongo中就可以，每一个线圈对应一个文档，单独建立一个lines的集合保存他们）。
 name-> 线圈的名字，用户画线圈时系统自动起的，用户也可以自己修改，从数据库中取
 ps-> 线圈点序列，也从数据库中取 
 {"lid": "2","name": "line2","ps": [[11,-1,10], [16,-10,15],[36,-10,15], [11,-1,10]]}

 4）GetObject.json-> 客户端加载已保存的矿体的接口，直接从mongo数据库中取出数据即可。
 例子：此格式是three.js标准的交互格式，不明白可以参考相关文档。其中metadata部分描述的version,和type为固定内容，
 object_name-> 矿体名称，系统在保存矿体时自动起的名字
 object_id-> 矿体在mongo数据库中的id（矿体只保存mongo中就可以，每一个矿体对应一个文档，单独建立一个objects的集合保存他们）。 
 vertices-> 矿体网格中节点的序列，每三个数字表示一个节点，分别代表x,y,z坐标
 faces-> 矿体网格三角片包含的节点的索引。比如 （0，0，1，3）代表，由vertices节点列表中的第0，1，3位置上的点组成的三角形，其中第一个数字0先不用管，写固定值0就行。
   {
        "metadata" :
        {
            "version": 4,
            "type": "geometry",
            "object_name": "k(l1-l2)",
            "object_id": "34324243242342"
        },
        "vertices":[11,-10,-11,21,-10,-11,12,-25,-11,11,-1,10,16,-10,15,36,-10,15],
        "faces":
            [
                0,0,1,3,
                0,2,3,4,
                0,0,2,3,
                0,1,3,5,
                0,1,2,5,
                0,2,4,5
            ]
    }

 5）connectline.json-> 客户端链接两个线圈时候向服务器发送两个线圈的节点信息，服务器调用算法生成矿体数据，并保存到mongo数据库，并返回给客户端这个格式的信息，让客户端画出刚建立的矿体
 例子：此格式是three.js标准的交互格式，不明白可以参考相关文档。基本和GetObject.json中的格式相同，
 其中多了两个属性：
 result-> 保存成功true,保存失败false
 message-> 如果失败，失败的原因
 {
    "result": true,
    "message": "建立实体错误",
    "metadata" : {
        "version": 4,
        "type": "geometry",
        "object_name": "k(l1-l2)",
        "object_id": "34324243242342"
    },

    "vertices":[11,-10,-11,21,-10,-11,12,-25,-11,11,-1,10,16,-10,15,36,-10,15],
    "faces": [0,0,1,3,
              0,2,3,4,
              0,0,2,3,
              0,1,3,5,
              0,1,2,5,
              0,2,4,5
    ]
 }
 6）endtopoint.json-> 客户端尖灭线圈到点时候向服务器发送线圈的节点信息，服务器要做的工作与返回的格式与链接线圈相似。
 7）endtoline.json-> 客户端尖灭线圈到点时候向服务器发送线圈的节点信息，服务器要做的工作与返回的格式与链接线圈相似。
 8) deleteobject.json-> 删除任何对象的时候，服务器返回的信息。内容基本不用解释。
 9）object.test.json-> 没用

putdata目录中，为客户端传给服务器的数据实例

 1) saveline.json->用户在画了一个线圈后将发出这样一个格式的数据给服务器，服务器把线圈的节点数组保存到mongo数据库中的lines集合中的一条记录，然 后返回getdata目录中savaline.json格式的数据给客户端表示保存是否成功，并返回线圈在mongo中的id.
 例：
 putdata中的saveline.json: 其中只有一个点序列，服务器需要保存到mongo中
 {
     "points":
         [
             {"x":11,"y":-10,"z":-11},
             {"x":21,"y":-10,"z":-11},
             {"x":12,"y":-25,"z":-11},
             {"x":11,"y":-10,"z":-11}
         ]
 }
 getdata中的saveline.json: 服务器返回的信息
 {
     "result": true,
     "message": "删除错误",
     "line_id": "sdfaf21323"
 }
 result-> 保存成功true,保存失败false
 message-> 如果失败，失败的原因
 line_id-> 保存的线圈在mongo中的id。客户端保存该id，以后对该线圈做的任何操作，都将返回这个id,服务器就可以直接用id找到改线圈

 2）connectline.json-> 客户端链接两个线圈时候向服务器发送两个线圈的节点信息，服务器调用算法生成矿体数据，并保存到mongo数据库,并返回getdata目录中connectline.json格式给客户端。
 例子：
 alg-> 使用的链接算法，1: 最小距离，2: 最小周长
 line1-> 线圈1的节点序列
 line2-> 线圈2的节点序列

 {
    "alg": 1,
    "line1":
        [
            {"x":11,"y":-1,"z":10},
            {"x":16,"y":-10,"z":15},
            {"x":36,"y":-10,"z":15},
            {"x":11,"y":-1,"z":10}
        ],
    "line2":
        [
            {"x":11,"y":-10,"z":-11},
            {"x":21,"y":-10,"z":-11},
            {"x":12,"y":-25,"z":-11},
            {"x":11,"y":-10,"z":-11}
        ]
 }

 3）endtopoint.json-> 客户端尖灭线圈到点时候向服务器发送线圈的节点信息，服务器要做的工作与返回的格式与链接线圈相似。
 type->尖灭到点 固定字段
 line-> 线圈节点序列
 distance-> 尖灭距离
 create_pl-> 时候创建点或者线

 {
    "type":"point",
    "line":[
            {"x":11,"y":-10,"z":-11},
            {"x":21,"y":-10,"z":-11},
            {"x":12,"y":-25,"z":-11},
            {"x":11,"y":-10,"z":-11}
           ],
    "distance":7,
    "create_pl":true
 }

 4）endtoline.json-> 客户端尖灭线圈到线时候向服务器发送线圈的节点信息，服务器要做的工作与返回的格式与链接线圈相似。
 type->尖灭到线 固定字段
 line-> 线圈节点序列
 distance-> 尖灭距离
 create_pl-> 时候创建点或者线
 line_short=> 短线界面
 line_scale_v-> 缩放
 line_point_num-> 点数
 {"type":"line",
    "line":
        [
            {"x":11,"y":-10,"z":-11},
            {"x":21,"y":-10,"z":-11},
            {"x":12,"y":-25,"z":-11},
            {"x":11,"y":-10,"z":-11}
        ],
    "distance":10,
    "create_pl":true,
    "line_short":true,
    "line_scale_v":1,
    "line_point_num":12
 }

 5）deleteobject.json-> 删除任何对象的时候，客户端发送的信息。内容基本不用解释。
 例子：
 type-> well, line, object
 {"type":"well","name":"n211","id":"4"}
